package ms3

import math "github.com/chewxy/math32"

// AppendGrid splits the argument bounds [Box] x,y,z axes by nx,ny,nz, respectively
// and generates points on the vertices generated by the division and appends them to dst, returning the result.
// All box edges are vertices in result. AppendGrid panics if it receives a dimension less than 2.
//
// Indexing is x-major, y-second-major:
//
//	grid := ms3.AppendGrid(nil, domain, nx, ny, nz)
//	ix, iy, iz := 1, 0, 3
//	pos := grid[iz*(nx+ny) + iy*nx + ix]
func AppendGrid(dst []Vec, domain Box, nx, ny, nz int) []Vec {
	if nx <= 1 || ny <= 1 || nz <= 1 {
		panic("AppendGrid needs more grid subdivisions")
	}
	nxyz := Vec{X: float32(nx - 1), Y: float32(ny - 1), Z: float32(nz - 1)}
	dxyz := DivElem(domain.Size(), nxyz)
	var xyz Vec
	for k := 0; k < nz; k++ {
		xyz.Z = domain.Min.Z + dxyz.Z*float32(k)
		for j := 0; j < ny; j++ {
			xyz.Y = domain.Min.Y + dxyz.Y*float32(j)
			for i := 0; i < nx; i++ {
				xyz.X = domain.Min.X + dxyz.X*float32(i)
				dst = append(dst, xyz)
			}
		}
	}
	return dst
}

// GridSubdomain facilitates obtaining the set of points in a grid shared between a domain box
// and a subdomain box contained within the domain box. Points of the grid should
// be ordered in x-major, y-second-major format, like the values returned by [AppendGrid].
//
//	istart, nxSub, nySub, nzSub := GridSubdomain(domain, nx, ny, nz, subdomain)
//	for iz := 0; iz < nzSub; iz++ {
//		offz := istart + iz*(nx+ny)
//		for iy := 0; iy < nySub; iy++ {
//			off := offz + iy*nx
//			for ix := 0; ix < nxSub; ix++ {
//				pointInSubdomain := grid[off+ix]
//				// do something with pointInSubdomain.
//			}
//		}
//	}
func GridSubdomain(domain Box, nxDomain, nyDomain, nzDomain int, subdomain Box) (iStart, nxSub, nySub, nzSub int) {
	if !domain.ContainsBox(subdomain) {
		panic("subdomain not contained in domain")
	}
	dx := (domain.Max.X - domain.Min.X) / float32(nxDomain-1)
	dy := (domain.Max.Y - domain.Min.Y) / float32(nyDomain-1)
	dz := (domain.Max.Z - domain.Min.Z) / float32(nzDomain-1)
	off := Sub(subdomain.Min, domain.Min)
	ix0 := iceil(off.X / dx)
	iy0 := iceil(off.Y / dy)
	iz0 := iceil(off.Z / dz)
	iStart = ix0 + iy0*nxDomain + iz0*(nxDomain+nyDomain)

	offEnd := Sub(subdomain.Max, domain.Min)
	ixf := int(offEnd.X / dx)
	iyf := int(offEnd.Y / dy)
	izf := int(offEnd.Z / dz)

	nxSub = ixf - ix0 + 1
	nySub = iyf - iy0 + 1
	nzSub = izf - iz0 + 1
	return iStart, nxSub, nySub, nzSub
}

func iceil(f float32) int {
	return int(math.Ceil(f))
}
