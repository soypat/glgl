//go:build generate

// Generates the mat package.
package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

const (
	filename = "mat_generated.go"
	ftype    = "float32"
	pkg      = "mat"
	colmajor = false
	header   = `package ` + pkg + `

// DO NOT EDIT.
// This file was generated automatically
// from codegen.go. Please do not edit this file.
//go:generate go run generate.go

`
)

// matrix with rows and columns
type Mat [2]int

func main() {

	file := new(bytes.Buffer)
	file.WriteString(header)
	mats := []Mat{
		{2, 2},
		{3, 3},
		{4, 4},
	}
	for _, m := range mats {
		var stride int
		var idxStr string
		name := m.TypeName()
		fmt.Fprintf(file, "type %v [%v * %v]%v\n\n", name, m[0], m[1], ftype)
		if colmajor {
			stride = m[1]
			idxStr = fmt.Sprintf("j*%v+i", stride)
		} else {
			stride = m[0]
			idxStr = fmt.Sprintf("i*%v+j", stride)
		}
		fmt.Fprintf(file, "func (a *%[1]v) Index(i, j int) int { return %[3]v }\n\n", name, ftype, idxStr)
		fmt.Fprintf(file, "func (a *%[1]v) at(i, j int) %[2]v { return a[%[3]v] }\n\n", name, ftype, idxStr)
		fmt.Fprintf(file, "func (a *%[1]v) set(i, j int, f %[2]v) { a[%[3]v] = f }\n\n", name, ftype, idxStr)
		fmt.Fprintf(file, `func (a *%[1]v) At(i, j int) %[2]v {
	if uint(i) > %[3]v || uint(j) > %[4]v {
		panic("bad at index")
	}
	return a.at(i, j)
}`+"\n\n", name, ftype, m[0]-1, m[1]-1)

		fmt.Fprintf(file, `func (a *%[1]v) Set(i, j int, f %[2]v) {
	if uint(i) > %[3]v || uint(j) > %[4]v {
		panic("bad set index")
	}
	a.set(i, j, f)
}`+"\n\n", name, ftype, m[0]-1, m[1]-1)

		fmt.Fprintf(file, "func (c *%[1]v) Add(a, b %[1]v) {\n%[2]v\n}\n\n", name, elemWise("c", "a[i]", "b[i]", "+"))
		fmt.Fprintf(file, "func (c *%[1]v) Sub(a, b %[1]v) {\n%[2]v\n}\n\n", name, elemWise("c", "a[i]", "b[i]", "-"))
		fmt.Fprintf(file, "func (c *%[1]v) Scale(f %[3]v, a %[1]v) {\n%[2]v\n}\n\n", name, elemWise("c", "f", "a[i]", "*"), ftype)
		fmt.Fprintf(file, "func (c *%[1]v) AddScalar(f %[3]v, a %[1]v) {\n%[2]v\n}\n\n", name, elemWise("c", "f", "a[i]", "+"), ftype)
		Muldef(file, m, m)
		Transdef(file, m)
		Eyedef(file, m[0])
		// TODO: Eye
	}
	fp, _ := os.Create(filename)
	fp.Write(file.Bytes())
}

func (m Mat) TypeName() string {
	if m[0] == m[1] {
		return fmt.Sprintf("Mat%v", m[0])
	}
	return fmt.Sprintf("Mat%vx%v", m[0], m[1])
}

func elemWise(c, a, b, op string) string {
	return fmt.Sprintf(`	for i := range ` + c + ` {
		` + c + `[i] = ` + a + " " + op + " " + b + `
	}`)
}

func Muldef(w io.Writer, A, B Mat) {
	if A[1] != B[0] {
		return
	}
	middle := A[1]
	result := Mat{A[0], B[1]}
	var suffix string
	if result[0] != result[1] {
		suffix = fmt.Sprintf("%vx%v", B[0], B[1])
	}

	fmt.Fprintf(w, "func (a *%[1]v) Mul%[2]v(b %[3]v) %[4]v {\n\treturn %[4]v{\n",
		A.TypeName(), suffix, B.TypeName(), result.TypeName())
	defer w.Write([]byte("\t}\n}\n\n"))
	for i := 0; i < result[0]; i++ {
		for j := 0; j < result[1]; j++ {
			for k := 0; k < middle; k++ {
				if k != 0 {
					w.Write([]byte(" + "))
				} else {
					w.Write([]byte("\t\t"))
				}
				fmt.Fprintf(w, "a.at(%[1]v, %[3]v)*b.at(%[3]v, %[2]v)", i, j, k)
			}
			w.Write([]byte(",\n"))
		}
	}
}

func Transdef(w io.Writer, A Mat) {
	name := A.TypeName()
	fmt.Fprintf(w, "func (a *%[1]v) Transpose() %[1]v {\n\treturn %[1]v{\n", name)
	defer w.Write([]byte("\t}\n}\n\n"))
	for i := 0; i < A[0]; i++ {
		for j := 0; j < A[1]; j++ {
			if j != 0 {
				w.Write([]byte(", "))
			} else {
				w.Write([]byte("\t\t"))
			}
			fmt.Fprintf(w, "a.at(%v, %v)", i, j)
		}
		w.Write([]byte(",\n"))
	}
}

func Eyedef(w io.Writer, n int) {
	A := Mat{n, n}
	name := A.TypeName()
	fmt.Fprintf(w, "func Eye%[2]v() %[1]v {\n\treturn %[1]v{\n", name, n)
	defer w.Write([]byte(",\n\t}\n}\n\n"))
	for i := 0; i < A[0]; i++ {
		for j := 0; j < A[1]; j++ {
			if j != 0 || i != 0 {
				w.Write([]byte(", "))
			} else {
				w.Write([]byte("\t\t"))
			}
			if i == j {
				fmt.Fprint(w, 1)
			} else {
				fmt.Fprint(w, 0)
			}
		}
	}
}
