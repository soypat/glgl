package main

// DO NOT EDIT.
// This file was generated automatically
// from codegen.go. Please do not edit this file.
//go:generate go run generate.go

type Mat2 [2 * 2]float32

func (a *Mat2) Index(i, j int) int { return i*2+j }

func (a *Mat2) at(i, j int) float32 { return a[i*2+j] }

func (a *Mat2) set(i, j int, f float32) { a[i*2+j] = f }

func (a *Mat2) At(i, j int) float32 {
	if uint(i) > 1 || uint(j) > 1 {
		panic("bad at index")
	}
	return a.at(i, j)
}

func (a *Mat2) Set(i, j int, f float32) {
	if uint(i) > 1 || uint(j) > 1 {
		panic("bad set index")
	}
	a.set(i, j, f)
}

func (c *Mat2) Add(a, b Mat2) {
	for i := range c {
		c[i] = a[i] + b[i]
	}
}

func (c *Mat2) Sub(a, b Mat2) {
	for i := range c {
		c[i] = a[i] - b[i]
	}
}

func (c *Mat2) Scale(f float32, a Mat2) {
	for i := range c {
		c[i] = f * a[i]
	}
}

func (c *Mat2) AddScalar(f float32, a Mat2) {
	for i := range c {
		c[i] = f + a[i]
	}
}

func (a *Mat2) Mul(b Mat2) Mat2 {
	return Mat2{
		a.at(0, 0)*b.at(0, 0) + a.at(0, 1)*b.at(1, 0),
		a.at(0, 0)*b.at(0, 1) + a.at(0, 1)*b.at(1, 1),
		a.at(1, 0)*b.at(0, 0) + a.at(1, 1)*b.at(1, 0),
		a.at(1, 0)*b.at(0, 1) + a.at(1, 1)*b.at(1, 1),
	}
}

func (a *Mat2) Transpose() Mat2 {
	return Mat2{
		a.at(0, 0), a.at(0, 1),
		a.at(1, 0), a.at(1, 1),
	}
}

func Eye2() Mat2 {
	return Mat2{
		1, 0, 0, 1,
	}
}

type Mat3 [3 * 3]float32

func (a *Mat3) Index(i, j int) int { return i*3+j }

func (a *Mat3) at(i, j int) float32 { return a[i*3+j] }

func (a *Mat3) set(i, j int, f float32) { a[i*3+j] = f }

func (a *Mat3) At(i, j int) float32 {
	if uint(i) > 2 || uint(j) > 2 {
		panic("bad at index")
	}
	return a.at(i, j)
}

func (a *Mat3) Set(i, j int, f float32) {
	if uint(i) > 2 || uint(j) > 2 {
		panic("bad set index")
	}
	a.set(i, j, f)
}

func (c *Mat3) Add(a, b Mat3) {
	for i := range c {
		c[i] = a[i] + b[i]
	}
}

func (c *Mat3) Sub(a, b Mat3) {
	for i := range c {
		c[i] = a[i] - b[i]
	}
}

func (c *Mat3) Scale(f float32, a Mat3) {
	for i := range c {
		c[i] = f * a[i]
	}
}

func (c *Mat3) AddScalar(f float32, a Mat3) {
	for i := range c {
		c[i] = f + a[i]
	}
}

func (a *Mat3) Mul(b Mat3) Mat3 {
	return Mat3{
		a.at(0, 0)*b.at(0, 0) + a.at(0, 1)*b.at(1, 0) + a.at(0, 2)*b.at(2, 0),
		a.at(0, 0)*b.at(0, 1) + a.at(0, 1)*b.at(1, 1) + a.at(0, 2)*b.at(2, 1),
		a.at(0, 0)*b.at(0, 2) + a.at(0, 1)*b.at(1, 2) + a.at(0, 2)*b.at(2, 2),
		a.at(1, 0)*b.at(0, 0) + a.at(1, 1)*b.at(1, 0) + a.at(1, 2)*b.at(2, 0),
		a.at(1, 0)*b.at(0, 1) + a.at(1, 1)*b.at(1, 1) + a.at(1, 2)*b.at(2, 1),
		a.at(1, 0)*b.at(0, 2) + a.at(1, 1)*b.at(1, 2) + a.at(1, 2)*b.at(2, 2),
		a.at(2, 0)*b.at(0, 0) + a.at(2, 1)*b.at(1, 0) + a.at(2, 2)*b.at(2, 0),
		a.at(2, 0)*b.at(0, 1) + a.at(2, 1)*b.at(1, 1) + a.at(2, 2)*b.at(2, 1),
		a.at(2, 0)*b.at(0, 2) + a.at(2, 1)*b.at(1, 2) + a.at(2, 2)*b.at(2, 2),
	}
}

func (a *Mat3) Transpose() Mat3 {
	return Mat3{
		a.at(0, 0), a.at(0, 1), a.at(0, 2),
		a.at(1, 0), a.at(1, 1), a.at(1, 2),
		a.at(2, 0), a.at(2, 1), a.at(2, 2),
	}
}

func Eye3() Mat3 {
	return Mat3{
		1, 0, 0, 0, 1, 0, 0, 0, 1,
	}
}

type Mat4 [4 * 4]float32

func (a *Mat4) Index(i, j int) int { return i*4+j }

func (a *Mat4) at(i, j int) float32 { return a[i*4+j] }

func (a *Mat4) set(i, j int, f float32) { a[i*4+j] = f }

func (a *Mat4) At(i, j int) float32 {
	if uint(i) > 3 || uint(j) > 3 {
		panic("bad at index")
	}
	return a.at(i, j)
}

func (a *Mat4) Set(i, j int, f float32) {
	if uint(i) > 3 || uint(j) > 3 {
		panic("bad set index")
	}
	a.set(i, j, f)
}

func (c *Mat4) Add(a, b Mat4) {
	for i := range c {
		c[i] = a[i] + b[i]
	}
}

func (c *Mat4) Sub(a, b Mat4) {
	for i := range c {
		c[i] = a[i] - b[i]
	}
}

func (c *Mat4) Scale(f float32, a Mat4) {
	for i := range c {
		c[i] = f * a[i]
	}
}

func (c *Mat4) AddScalar(f float32, a Mat4) {
	for i := range c {
		c[i] = f + a[i]
	}
}

func (a *Mat4) Mul(b Mat4) Mat4 {
	return Mat4{
		a.at(0, 0)*b.at(0, 0) + a.at(0, 1)*b.at(1, 0) + a.at(0, 2)*b.at(2, 0) + a.at(0, 3)*b.at(3, 0),
		a.at(0, 0)*b.at(0, 1) + a.at(0, 1)*b.at(1, 1) + a.at(0, 2)*b.at(2, 1) + a.at(0, 3)*b.at(3, 1),
		a.at(0, 0)*b.at(0, 2) + a.at(0, 1)*b.at(1, 2) + a.at(0, 2)*b.at(2, 2) + a.at(0, 3)*b.at(3, 2),
		a.at(0, 0)*b.at(0, 3) + a.at(0, 1)*b.at(1, 3) + a.at(0, 2)*b.at(2, 3) + a.at(0, 3)*b.at(3, 3),
		a.at(1, 0)*b.at(0, 0) + a.at(1, 1)*b.at(1, 0) + a.at(1, 2)*b.at(2, 0) + a.at(1, 3)*b.at(3, 0),
		a.at(1, 0)*b.at(0, 1) + a.at(1, 1)*b.at(1, 1) + a.at(1, 2)*b.at(2, 1) + a.at(1, 3)*b.at(3, 1),
		a.at(1, 0)*b.at(0, 2) + a.at(1, 1)*b.at(1, 2) + a.at(1, 2)*b.at(2, 2) + a.at(1, 3)*b.at(3, 2),
		a.at(1, 0)*b.at(0, 3) + a.at(1, 1)*b.at(1, 3) + a.at(1, 2)*b.at(2, 3) + a.at(1, 3)*b.at(3, 3),
		a.at(2, 0)*b.at(0, 0) + a.at(2, 1)*b.at(1, 0) + a.at(2, 2)*b.at(2, 0) + a.at(2, 3)*b.at(3, 0),
		a.at(2, 0)*b.at(0, 1) + a.at(2, 1)*b.at(1, 1) + a.at(2, 2)*b.at(2, 1) + a.at(2, 3)*b.at(3, 1),
		a.at(2, 0)*b.at(0, 2) + a.at(2, 1)*b.at(1, 2) + a.at(2, 2)*b.at(2, 2) + a.at(2, 3)*b.at(3, 2),
		a.at(2, 0)*b.at(0, 3) + a.at(2, 1)*b.at(1, 3) + a.at(2, 2)*b.at(2, 3) + a.at(2, 3)*b.at(3, 3),
		a.at(3, 0)*b.at(0, 0) + a.at(3, 1)*b.at(1, 0) + a.at(3, 2)*b.at(2, 0) + a.at(3, 3)*b.at(3, 0),
		a.at(3, 0)*b.at(0, 1) + a.at(3, 1)*b.at(1, 1) + a.at(3, 2)*b.at(2, 1) + a.at(3, 3)*b.at(3, 1),
		a.at(3, 0)*b.at(0, 2) + a.at(3, 1)*b.at(1, 2) + a.at(3, 2)*b.at(2, 2) + a.at(3, 3)*b.at(3, 2),
		a.at(3, 0)*b.at(0, 3) + a.at(3, 1)*b.at(1, 3) + a.at(3, 2)*b.at(2, 3) + a.at(3, 3)*b.at(3, 3),
	}
}

func (a *Mat4) Transpose() Mat4 {
	return Mat4{
		a.at(0, 0), a.at(0, 1), a.at(0, 2), a.at(0, 3),
		a.at(1, 0), a.at(1, 1), a.at(1, 2), a.at(1, 3),
		a.at(2, 0), a.at(2, 1), a.at(2, 2), a.at(2, 3),
		a.at(3, 0), a.at(3, 1), a.at(3, 2), a.at(3, 3),
	}
}

func Eye4() Mat4 {
	return Mat4{
		1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
	}
}

